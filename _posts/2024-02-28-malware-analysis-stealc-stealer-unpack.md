---
title: "Malware Analysis - Stealc stealer unpacking"
date: 2024-02-28 13:34:00 +0300
author: cozy 
categories: [malware, unpacking, stealer]
---

## File information

`SHA256: ff7167a57007b5368518b03e82ae9110aa55ba9e947719308a416f3aecdc75e1`

![](/images/stealc_unpacking/vt.png)\
Первичный файл является упакованным(мы живем в обществе), строки норм адекватные, являются аргументами функций, которые вызываются просто чтобы(^-^)\ 
![](/images/stealc_unpacking/1.png)\
ненужные функции, по приколу\
![](/images/stealc_unpacking/2.png)\
![](/images/stealc_unpacking/3.png)\
есть jmp на смешной dword, нам туда надо\
![](/images/stealc_unpacking/4.png)\
в одном из моментов нужно быть попроще и по мужски занопить\
![](/images/stealc_unpacking/5.png)\
с легкостью находим данный jmp, смотрит куда он ведет в памяти и внезапно shellcode, дампим смотрим\
![](/images/stealc_unpacking/6.png)\
\
изначально вызов функций\
![](/images/stealc_unpacking/7.png)\
первая функция `sub_e5f2` - резолв WinApi динамически
функция `sub_e653` - custom GetModuleHandle\
![](/images/stealc_unpacking/8.png)\
![](/images/stealc_unpacking/9.png)\
![](/images/stealc_unpacking/10.png)\
в следующей функции из начала `jmp [ebp+var_4]`, поэтому также берем все мужское и идем туда\
![](/images/stealc_unpacking/11.png)\
получается имеем новый shellcode. даммммпим\
![](/images/stealc_unpacking/12.png)\
в данном шеллкоде интересует последний call\
![](/images/stealc_unpacking/13.png)\
заполнение памяти адресами функций\
![](/images/stealc_unpacking/14.png)\
очень хотим в конец функции на удивительный jmp\
![](/images/stealc_unpacking/15.png)\
также во время исполнения данного шеллкода происходит инициализация всех секций(.text, .rdata, .idata и т.д.), из-за чего данный jmp указывает на начало секции .text нужного исполняемого файла. дампим\
![](/images/stealc_unpacking/17.png)\
получаем нужный бинарь\
![](/images/stealc_unpacking/18.png)

можно также добавить про декод строк, все строки заенкожены в base64 + rc4.\
![](/images/stealc_unpacking/19.png)\
Поэтому мини скрипт([взял отсюда + подправил для себя](https://mssplab.github.io/threat-hunting/2023/11/09/malware-analysis-stealc-1.html))
```python
import idautils  
import idc  
import ida_idaapi, ida_kernwin, ida_bytes, ida_name
import base64  
RC4_Key = b'placeRc4KeyHere'

def check_str(decrypted_str):
    decrypted_str = decrypted_str.replace(' ', '_')
    if decrypted_str.isdigit():
        decrypted_str = '_' + decrypted_str
    if '/' in decrypted_str or '\\' in decrypted_str:
        decrypted_str = decrypted_str.replace('/', '_')
        decrypted_str = decrypted_str.replace('\\', '_')
    if ',' in decrypted_str:
        decrypted_str = decrypted_str.replace(',', '_commaHere_')
    if '(' in decrypted_str or ')' in decrypted_str or '-' in decrypted_str:
        decrypted_str = decrypted_str.replace('(', '_')
        decrypted_str = decrypted_str.replace(')', '_')
        decrypted_str = decrypted_str.replace('-', '_')
    if ':' in decrypted_str:
        decrypted_str = decrypted_str.replace(':', '_')
    if '*' in decrypted_str:
        decrypted_str = decrypted_str.replace('*', '_')
    return decrypted_str
    
def rc4_decrypt(ciphertext, key):  
    S = list(range(256))  
    j = 0  
    key_length = len(key)  
    plaintext = bytearray(len(ciphertext))  
  
    for i in range(256):  
        j = (j + S[i] + key[i % key_length]) % 256  
        S[i], S[j] = S[j], S[i]  
  
  
    i = j = 0  
    for idx, byte in enumerate(ciphertext):  
        i = (i + 1) % 256  
        j = (j + S[i]) % 256  
        S[i], S[j] = S[j], S[i]  
        keystream_byte = S[(S[i] + S[j]) % 256]  
        if byte == 0x00:
             continue  
        else :  
            plaintext[idx] = byte ^ keystream_byte  
  
    return bytes(plaintext)  
      
def Modify_Xrefs(Decryption_routin):  
    Xrefs = idautils.CodeRefsTo(Decryption_routin,0)  
    count=0  
    for x in Xrefs:  
        ea = idc.prev_head(x)    
        operand_address = idc.get_operand_value(ea,0)
        size = 200  
        data__ = idaapi.get_bytes(operand_address,size)
        print(data__)
        if operand_address != -1 :  
            index=data__.index(b'\x00\x00')  
            count +=1  
            data__=data__[:index]
            decrypted_str = rc4_decrypt(base64.b64decode(data__),RC4_Key).decode('utf-8',errors='ignore')
            decrypted_str = check_str(decrypted_str)
            idc.set_cmt(x,decrypted_str,0)  
            dword_address = idc.next_head(x + 5)
            dword_value = idc.get_operand_value(dword_address,0)
            rename_operand(dword_value,decrypted_str)
        else:
            continue  
def rename_operand(address,string):  
    ida_name.set_name(address, string, ida_name.SN_CHECK)  
Decryption_fun_address = 0x00404250 #place decryption func addr here  
Modify_Xrefs(Decryption_fun_address)
```
если че я не умею в питон поэтому не надо пиздить палками за это.
если надо почитать про функционал малвари то найдите сами, мне просто в прикол было распаковать.
\
**все грац вы великолепны удачи успехов кайфуйте.**
